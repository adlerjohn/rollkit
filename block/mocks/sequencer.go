package mocks

import (
	"context"

	"github.com/stretchr/testify/mock"

	coresequencer "github.com/rollkit/rollkit/core/sequencer"
)

// Sequencer is an autogenerated mock type for the Sequencer type
type Sequencer struct {
	mock.Mock
}

// GetNextBatch provides a mock function with given fields: ctx, req
func (_m *Sequencer) GetNextBatch(ctx context.Context, req coresequencer.GetNextBatchRequest) (*coresequencer.GetNextBatchResponse, error) {
	ret := _m.Called(ctx, req)

	var r0 *coresequencer.GetNextBatchResponse
	if rf, ok := ret.Get(0).(func(context.Context, coresequencer.GetNextBatchRequest) *coresequencer.GetNextBatchResponse); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coresequencer.GetNextBatchResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, coresequencer.GetNextBatchRequest) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubmitRollupBatchTxs provides a mock function with given fields: ctx, req
func (_m *Sequencer) SubmitRollupBatchTxs(ctx context.Context, req coresequencer.SubmitRollupBatchTxsRequest) (*coresequencer.SubmitRollupBatchTxsResponse, error) {
	ret := _m.Called(ctx, req)

	var r0 *coresequencer.SubmitRollupBatchTxsResponse
	if rf, ok := ret.Get(0).(func(context.Context, coresequencer.SubmitRollupBatchTxsRequest) *coresequencer.SubmitRollupBatchTxsResponse); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coresequencer.SubmitRollupBatchTxsResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, coresequencer.SubmitRollupBatchTxsRequest) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VerifyBatch provides a mock function with given fields: ctx, req
func (_m *Sequencer) VerifyBatch(ctx context.Context, req coresequencer.VerifyBatchRequest) (*coresequencer.VerifyBatchResponse, error) {
	ret := _m.Called(ctx, req)

	var r0 *coresequencer.VerifyBatchResponse
	if rf, ok := ret.Get(0).(func(context.Context, coresequencer.VerifyBatchRequest) *coresequencer.VerifyBatchResponse); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coresequencer.VerifyBatchResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, coresequencer.VerifyBatchRequest) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewSequencer creates a new instance of Sequencer. It also registers a testing interface on the mock.
// The first argument is typically a *testing.T value.
// Remember to call AssertExpectations manually at the end of your test.
func NewSequencer(t mock.TestingT) *Sequencer {
	mock := &Sequencer{}
	mock.Mock.Test(t)
	// t.Cleanup(func() { mock.AssertExpectations(t) }) // Remove automatic cleanup
	return mock
}
